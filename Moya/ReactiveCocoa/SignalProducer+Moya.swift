import Foundation
import ReactiveCocoa

/// Extension for processing raw NSData generated by network access.
extension SignalProducer where T: MoyaResponse, E: NSError {
    
    /// Filters out responses that don't fall within the given range, generating errors when others are encountered.
    public func filterStatusCodes(range: ClosedInterval<Int>) -> SignalProducer<T, E> {
        return flatMap(FlattenStrategy.Merge, transform: { response in
            return SignalProducer<T, E> { sink, disposable in
                if range.contains(response.statusCode) {
                    sendNext(sink, response)
                    sendCompleted(sink)
                } else {
                    let error = NSError(domain: MoyaErrorDomain, code: MoyaErrorCode.StatusCode.rawValue, userInfo: ["data": response]) as! E
                    sendError(sink, error)
                }
            }
        })
    }
    
    public func filterStatusCode(code: Int) -> SignalProducer<T, E> {
        return filterStatusCodes(code...code)
    }
    
    public func filterSuccessfulStatusCodes() -> SignalProducer<T, E> {
        return filterStatusCodes(200...299)
    }
    
    public func filterSuccessfulStatusAndRedirectCodes() -> SignalProducer<T, E> {
        return filterStatusCodes(200...399)
    }
    
    /// Maps data received from the signal into a UIImage. If the conversion fails, the signal errors.
    public func mapImage() -> SignalProducer<UIImage, E> {
        return flatMap(FlattenStrategy.Merge, transform: { response in
            return SignalProducer<UIImage, E> { sink, disposable in
                guard let image = UIImage(data: response.data) else {
                    let error = NSError(domain: MoyaErrorDomain, code: MoyaErrorCode.ImageMapping.rawValue, userInfo: ["data": response]) as! E
                    sendError(sink, error)
                    return
                }
                sendNext(sink, image)
                sendCompleted(sink)
            }
        })
    }
    
    /// Maps data received from the signal into a JSON object. If the conversion fails, the signal errors.
    public func mapJSON() -> SignalProducer<AnyObject, E> {
        return flatMap(FlattenStrategy.Merge, transform: { response in
            return SignalProducer<AnyObject, E> { sink, disposable in
                do {
                    let jsonObject = try NSJSONSerialization.JSONObjectWithData(response.data, options: NSJSONReadingOptions.AllowFragments)
                    sendNext(sink, jsonObject)
                    sendCompleted(sink)
                } catch {
                    //let error = NSError(domain: MoyaErrorDomain, code: MoyaErrorCode.JSONMapping.rawValue, userInfo: ["data": response]) as! E
                    sendError(sink, error as! E)
                }
            }
        })
    }
    
    /// Maps data received from the signal into a String. If the conversion fails, the signal errors.
    public func mapString() -> SignalProducer<String, E> {
        return flatMap(FlattenStrategy.Merge, transform: { response in
            return SignalProducer<String, E> { sink, disposable in
                guard let string = NSString(data: response.data, encoding: NSUTF8StringEncoding) as? String else {
                    let error = NSError(domain: MoyaErrorDomain, code: MoyaErrorCode.StringMapping.rawValue, userInfo: ["data": response]) as! E
                    sendError(sink, error)
                    return
                }
                sendNext(sink, string)
                sendCompleted(sink)
            }
        })
    }
}